const express = require('express');
const path = require('path');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cookieParser = require('cookie-parser');
require('dotenv').config();

// Log temporal para verificar variables de entorno
console.log('üîç Variables de entorno cargadas:');
console.log('   DB_HOST:', process.env.DB_HOST);
console.log('   DB_USER:', process.env.DB_USER);
console.log('   DB_NAME:', process.env.DB_NAME);
console.log('   DB_PORT:', process.env.DB_PORT);
console.log('   NODE_ENV:', process.env.NODE_ENV);

// Importar configuraci√≥n de base de datos
const { initializeDatabase } = require('./config/db');
const { initializeDatabase: initDbComplete } = require('./config/initDb');

// Importar servicio de turnos
const AppointmentService = require('./services/appointmentService');

// Importar middleware
const { requestLogger, errorHandler } = require('./middleware/auth');

// Importar rutas
const authRoutes = require('./routes/auth');
const dashboardRoutes = require('./routes/dashboard');
const publicRoutes = require('./routes/public');
const bookingRoutes = require('./routes/booking');
const clientRoutes = require('./routes/clients');
const scheduleRoutes = require('./routes/schedule');
const reportsRoutes = require('./routes/reports');
const employeeRoutes = require('./routes/employees');
const adminRoutes = require('./routes/admin');
const appointmentRoutes = require('./routes/appointments');

// Crear la aplicaci√≥n Express
const app = express();
const PORT = process.env.PORT || 3000;

// Configurar rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // l√≠mite de 100 requests por ventana
    message: {
        success: false,
        message: 'Demasiadas solicitudes desde esta IP, intenta de nuevo m√°s tarde.'
    }
});

// Middleware de seguridad
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net", "https://fonts.googleapis.com", "https://cdnjs.cloudflare.com"],
            scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
            scriptSrcAttr: ["'unsafe-inline'"],
            fontSrc: ["'self'", "https://fonts.gstatic.com", "https://cdnjs.cloudflare.com"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"]
        }
    }
}));

// Configurar CORS
app.use(cors({
    origin: process.env.NODE_ENV === 'production' 
        ? ['https://tu-dominio.com'] 
        : ['http://localhost:3000', 'http://127.0.0.1:3000'],
    credentials: true
}));

// Middleware para parsear JSON y cookies
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// Middleware de logging
app.use(requestLogger);

// Servir archivos est√°ticos ANTES del rate limiting
app.use('/public', express.static('public'));
app.use('/views', express.static('views'));

// Middleware para servir archivos est√°ticos espec√≠ficos
app.use((req, res, next) => {
    // Manejar archivos CSS y JS de la p√°gina p√∫blica (desde la ra√≠z)
    if (req.path === '/styles.css') {
        return res.sendFile(path.join(__dirname, 'public', 'styles.css'));
    }
    if (req.path === '/script.js') {
        return res.sendFile(path.join(__dirname, 'public', 'script.js'));
    }
    
    // Manejar im√°genes desde la ra√≠z
    if (req.path.startsWith('/img/')) {
        const imagePath = req.path.replace('/img/', '');
        return res.sendFile(path.join(__dirname, 'public', 'img', imagePath));
    }
    
    next();
});

// Rutas para archivos est√°ticos del dashboard
app.use('/views/dashboard', express.static(path.join(__dirname, 'views/dashboard')));

// Aplicar rate limiting SOLO a rutas API despu√©s de los archivos est√°ticos
app.use('/api', limiter);
app.use('/dashboard', limiter);
app.use('/auth', limiter);

// Ruta principal (p√∫blica)
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Rutas p√∫blicas del usuario
app.use('/', publicRoutes);

// Rutas de autenticaci√≥n
app.use('/auth', authRoutes);

// Rutas del dashboard (protegidas)
app.use('/dashboard', dashboardRoutes);

// Rutas de booking (API p√∫blica)
app.use('/api/booking', bookingRoutes);

// Rutas de clientes (API protegida)
app.use('/api/clients', clientRoutes);

// Rutas de horarios (API protegida)
app.use('/api/schedule', scheduleRoutes);

// Rutas API generales (protegidas)
const apiRoutes = require('./routes/api');
app.use('/api', apiRoutes);

// Rutas de reportes (API protegida) - Comentado temporalmente para evitar conflictos
// app.use('/api/reports', reportsRoutes);

// Rutas de gesti√≥n de barberos (API protegida - solo admins)
app.use('/api/employees', employeeRoutes);

// Rutas de administraci√≥n del sistema (API protegida - solo admins)
app.use('/api/admin', adminRoutes);

// Rutas de gesti√≥n de turnos (API protegida)
app.use('/api/appointments', appointmentRoutes);

// Ruta de redirecci√≥n para usuarios autenticados
app.get('/login', (req, res) => {
    res.redirect('/auth/login');
});

app.get('/register', (req, res) => {
    res.redirect('/auth/register');
});

// Ruta de prueba de API
app.get('/api/test', (req, res) => {
    res.json({ 
        success: true, 
        message: 'API funcionando correctamente',
        timestamp: new Date().toISOString()
    });
});

// Middleware para manejar rutas no encontradas
app.use((req, res, next) => {
    if (res.headersSent) {
        return next();
    }
    if (req.path.startsWith('/api/')) {
        return res.status(404).json({
            success: false,
            message: 'Endpoint no encontrado'
        });
    }
    return res.redirect('/');
});

// Middleware para manejar errores
app.use(errorHandler);

// Funci√≥n para iniciar el servidor
async function startServer() {
    try {
        // Inicializar base de datos
        console.log('üîÑ Inicializando base de datos...');
        await initializeDatabase();
        console.log('‚úÖ Base de datos inicializada correctamente');

        // Inicializar estructura y datos
        console.log('üîÑ Inicializando estructura de tablas...');
        await initDbComplete();
        console.log('‚úÖ Estructura de tablas inicializada correctamente');

        // Iniciar servidor
        app.listen(PORT, () => {
            console.log(`üöÄ Servidor iniciado en http://localhost:${PORT}`);
            console.log(`üìä Dashboard: http://localhost:${PORT}/dashboard`);
            console.log(`üîê Login: http://localhost:${PORT}/auth/login`);
            console.log(`üìù Registro: http://localhost:${PORT}/auth/register`);
            console.log(`üìÖ Reservas: http://localhost:${PORT}/booking`);
        });
        
        // Configurar tareas programadas despu√©s de iniciar el servidor
        scheduledTasks = setupScheduledTasks();
        
        // Ejecutar actualizaci√≥n inicial de turnos
        console.log('üöÄ Ejecutando actualizaci√≥n inicial de turnos...');
        AppointmentService.autoCompleteAppointments()
            .then(result => {
                if (result.updatedCount > 0) {
                    console.log(`‚úÖ Actualizaci√≥n inicial completada: ${result.updatedCount} turnos marcados como completados`);
                } else {
                    console.log('‚úÖ Actualizaci√≥n inicial completada: No hay turnos pendientes para actualizar');
                }
            })
            .catch(error => {
                console.error('‚ùå Error en actualizaci√≥n inicial:', error);
            });
    } catch (error) {
        console.error('‚ùå Error al iniciar el servidor:', error);
        process.exit(1);
    }
}

// Funci√≥n para configurar tareas programadas
function setupScheduledTasks() {
    console.log('‚è∞ Configurando tareas programadas...');
    
    // Tarea 1: Actualizar turnos autom√°ticamente cada 5 minutos
    const autoCompleteInterval = setInterval(async () => {
        try {
            console.log('üîÑ Ejecutando tarea programada: Actualizaci√≥n autom√°tica de turnos...');
            const result = await AppointmentService.autoCompleteAppointments();
            
            if (result.updatedCount > 0) {
                console.log(`‚úÖ Tarea completada: ${result.updatedCount} turnos marcados como completados`);
            } else {
                console.log('‚úÖ Tarea completada: No hay turnos pendientes para actualizar');
            }
        } catch (error) {
            console.error('‚ùå Error en tarea programada de auto-completado:', error);
        }
    }, 5 * 60 * 1000); // 5 minutos
    
    // Tarea 2: Actualizar turnos al inicio del d√≠a (00:01 AM)
    const dailyUpdateInterval = setInterval(async () => {
        try {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Ejecutar solo a las 00:01 AM
            if (currentHour === 0 && currentMinute === 1) {
                console.log('üåÖ Ejecutando tarea diaria: Actualizaci√≥n de turnos del d√≠a anterior...');
                const result = await AppointmentService.autoCompleteAppointments();
                
                if (result.updatedCount > 0) {
                    console.log(`‚úÖ Tarea diaria completada: ${result.updatedCount} turnos del d√≠a anterior marcados como completados`);
                } else {
                    console.log('‚úÖ Tarea diaria completada: No hay turnos del d√≠a anterior para actualizar');
                }
            }
        } catch (error) {
            console.error('‚ùå Error en tarea diaria de auto-completado:', error);
        }
    }, 60 * 1000); // Verificar cada minuto
    
    console.log('‚úÖ Tareas programadas configuradas:');
    console.log('   - Actualizaci√≥n autom√°tica cada 5 minutos');
    console.log('   - Actualizaci√≥n diaria a las 00:01 AM');
    
    // Retornar los intervalos para poder limpiarlos si es necesario
    return { autoCompleteInterval, dailyUpdateInterval };
}

// Variables globales para las tareas programadas
let scheduledTasks = null;

// Manejar se√±ales de terminaci√≥n
process.on('SIGINT', () => {
    console.log('\nüõë Cerrando servidor...');
    
    // Limpiar tareas programadas
    if (scheduledTasks) {
        clearInterval(scheduledTasks.autoCompleteInterval);
        clearInterval(scheduledTasks.dailyUpdateInterval);
        console.log('üßπ Tareas programadas limpiadas');
    }
    
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Cerrando servidor...');
    
    // Limpiar tareas programadas
    if (scheduledTasks) {
        clearInterval(scheduledTasks.autoCompleteInterval);
        clearInterval(scheduledTasks.dailyUpdateInterval);
        console.log('üßπ Tareas programadas limpiadas');
    }
    
    process.exit(0);
});

// Iniciar servidor
startServer();

module.exports = app;
